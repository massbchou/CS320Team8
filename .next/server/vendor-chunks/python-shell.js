"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/python-shell";
exports.ids = ["vendor-chunks/python-shell"];
exports.modules = {

/***/ "(rsc)/./node_modules/python-shell/index.js":
/*!********************************************!*\
  !*** ./node_modules/python-shell/index.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nvar __awaiter = (void 0) && (void 0).__awaiter || function(thisArg, _arguments, P, generator) {\n    function adopt(value) {\n        return value instanceof P ? value : new P(function(resolve) {\n            resolve(value);\n        });\n    }\n    return new (P || (P = Promise))(function(resolve, reject) {\n        function fulfilled(value) {\n            try {\n                step(generator.next(value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function rejected(value) {\n            try {\n                step(generator[\"throw\"](value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function step(result) {\n            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n        }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.PythonShell = exports.NewlineTransformer = exports.PythonShellErrorWithLogs = exports.PythonShellError = void 0;\nconst events_1 = __webpack_require__(/*! events */ \"events\");\nconst child_process_1 = __webpack_require__(/*! child_process */ \"child_process\");\nconst os_1 = __webpack_require__(/*! os */ \"os\");\nconst path_1 = __webpack_require__(/*! path */ \"path\");\nconst stream_1 = __webpack_require__(/*! stream */ \"stream\");\nconst fs_1 = __webpack_require__(/*! fs */ \"fs\");\nconst util_1 = __webpack_require__(/*! util */ \"util\");\nfunction toArray(source) {\n    if (typeof source === \"undefined\" || source === null) {\n        return [];\n    } else if (!Array.isArray(source)) {\n        return [\n            source\n        ];\n    }\n    return source;\n}\n/**\r\n * adds arguments as properties to obj\r\n */ function extend(obj, ...args) {\n    Array.prototype.slice.call(arguments, 1).forEach(function(source) {\n        if (source) {\n            for(let key in source){\n                obj[key] = source[key];\n            }\n        }\n    });\n    return obj;\n}\n/**\r\n * gets a random int from 0-10000000000\r\n */ function getRandomInt() {\n    return Math.floor(Math.random() * 10000000000);\n}\nconst execPromise = (0, util_1.promisify)(child_process_1.exec);\nclass PythonShellError extends Error {\n}\nexports.PythonShellError = PythonShellError;\nclass PythonShellErrorWithLogs extends PythonShellError {\n}\nexports.PythonShellErrorWithLogs = PythonShellErrorWithLogs;\n/**\r\n * Takes in a string stream and emits batches seperated by newlines\r\n */ class NewlineTransformer extends stream_1.Transform {\n    _transform(chunk, encoding, callback) {\n        let data = chunk.toString();\n        if (this._lastLineData) data = this._lastLineData + data;\n        const lines = data.split(os_1.EOL);\n        this._lastLineData = lines.pop();\n        //@ts-ignore this works, node ignores the encoding if it's a number\n        lines.forEach(this.push.bind(this));\n        callback();\n    }\n    _flush(done) {\n        if (this._lastLineData) this.push(this._lastLineData);\n        this._lastLineData = null;\n        done();\n    }\n}\nexports.NewlineTransformer = NewlineTransformer;\n/**\r\n * An interactive Python shell exchanging data through stdio\r\n * @param {string} script    The python script to execute\r\n * @param {object} [options] The launch options (also passed to child_process.spawn)\r\n * @param [stdoutSplitter] Optional. Splits stdout into chunks, defaulting to splitting into newline-seperated lines\r\n * @param [stderrSplitter] Optional. splits stderr into chunks, defaulting to splitting into newline-seperated lines\r\n * @constructor\r\n */ class PythonShell extends events_1.EventEmitter {\n    /**\r\n     * spawns a python process\r\n     * @param scriptPath path to script. Relative to current directory or options.scriptFolder if specified\r\n     * @param options\r\n     * @param stdoutSplitter Optional. Splits stdout into chunks, defaulting to splitting into newline-seperated lines\r\n     * @param stderrSplitter Optional. splits stderr into chunks, defaulting to splitting into newline-seperated lines\r\n     */ constructor(scriptPath, options, stdoutSplitter = null, stderrSplitter = null){\n        super();\n        /**\r\n         * returns either pythonshell func (if val string) or custom func (if val Function)\r\n         */ function resolve(type, val) {\n            if (typeof val === \"string\") {\n                // use a built-in function using its name\n                return PythonShell[type][val];\n            } else if (typeof val === \"function\") {\n                // use a custom function\n                return val;\n            }\n        }\n        if (scriptPath.trim().length == 0) throw Error(\"scriptPath cannot be empty! You must give a script for python to run\");\n        let self = this;\n        let errorData = \"\";\n        events_1.EventEmitter.call(this);\n        options = extend({}, PythonShell.defaultOptions, options);\n        let pythonPath;\n        if (!options.pythonPath) {\n            pythonPath = PythonShell.defaultPythonPath;\n        } else pythonPath = options.pythonPath;\n        let pythonOptions = toArray(options.pythonOptions);\n        let scriptArgs = toArray(options.args);\n        this.scriptPath = (0, path_1.join)(options.scriptPath || \"\", scriptPath);\n        this.command = pythonOptions.concat(this.scriptPath, scriptArgs);\n        this.mode = options.mode || \"text\";\n        this.formatter = resolve(\"format\", options.formatter || this.mode);\n        this.parser = resolve(\"parse\", options.parser || this.mode);\n        // We don't expect users to ever format stderr as JSON so we default to text mode\n        this.stderrParser = resolve(\"parse\", options.stderrParser || \"text\");\n        this.terminated = false;\n        this.childProcess = (0, child_process_1.spawn)(pythonPath, this.command, options);\n        [\n            \"stdout\",\n            \"stdin\",\n            \"stderr\"\n        ].forEach(function(name) {\n            self[name] = self.childProcess[name];\n            self.parser && self[name] && self[name].setEncoding(options.encoding || \"utf8\");\n        });\n        // Node buffers stdout&stderr in batches regardless of newline placement\n        // This is troublesome if you want to recieve distinct individual messages\n        // for example JSON parsing breaks if it recieves partial JSON\n        // so we use newlineTransformer to emit each batch seperated by newline\n        if (this.parser && this.stdout) {\n            if (!stdoutSplitter) stdoutSplitter = new NewlineTransformer();\n            // note that setting the encoding turns the chunk into a string\n            stdoutSplitter.setEncoding(options.encoding || \"utf8\");\n            this.stdout.pipe(stdoutSplitter).on(\"data\", (chunk)=>{\n                this.emit(\"message\", self.parser(chunk));\n            });\n        }\n        // listen to stderr and emit errors for incoming data\n        if (this.stderrParser && this.stderr) {\n            if (!stderrSplitter) stderrSplitter = new NewlineTransformer();\n            // note that setting the encoding turns the chunk into a string\n            stderrSplitter.setEncoding(options.encoding || \"utf8\");\n            this.stderr.pipe(stderrSplitter).on(\"data\", (chunk)=>{\n                this.emit(\"stderr\", self.stderrParser(chunk));\n            });\n        }\n        if (this.stderr) {\n            this.stderr.on(\"data\", function(data) {\n                errorData += \"\" + data;\n            });\n            this.stderr.on(\"end\", function() {\n                self.stderrHasEnded = true;\n                terminateIfNeeded();\n            });\n        } else {\n            self.stderrHasEnded = true;\n        }\n        if (this.stdout) {\n            this.stdout.on(\"end\", function() {\n                self.stdoutHasEnded = true;\n                terminateIfNeeded();\n            });\n        } else {\n            self.stdoutHasEnded = true;\n        }\n        this.childProcess.on(\"error\", function(err) {\n            self.emit(\"error\", err);\n        });\n        this.childProcess.on(\"exit\", function(code, signal) {\n            self.exitCode = code;\n            self.exitSignal = signal;\n            terminateIfNeeded();\n        });\n        function terminateIfNeeded() {\n            if (!self.stderrHasEnded || !self.stdoutHasEnded || self.exitCode == null && self.exitSignal == null) return;\n            let err;\n            if (self.exitCode && self.exitCode !== 0) {\n                if (errorData) {\n                    err = self.parseError(errorData);\n                } else {\n                    err = new PythonShellError(\"process exited with code \" + self.exitCode);\n                }\n                err = extend(err, {\n                    executable: pythonPath,\n                    options: pythonOptions.length ? pythonOptions : null,\n                    script: self.scriptPath,\n                    args: scriptArgs.length ? scriptArgs : null,\n                    exitCode: self.exitCode\n                });\n                // do not emit error if only a callback is used\n                if (self.listeners(\"pythonError\").length || !self._endCallback) {\n                    self.emit(\"pythonError\", err);\n                }\n            }\n            self.terminated = true;\n            self.emit(\"close\");\n            self._endCallback && self._endCallback(err, self.exitCode, self.exitSignal);\n        }\n        ;\n    }\n    /**\r\n     * checks syntax without executing code\r\n     * @returns rejects promise w/ string error output if syntax failure\r\n     */ static checkSyntax(code) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const randomInt = getRandomInt();\n            const filePath = (0, os_1.tmpdir)() + path_1.sep + `pythonShellSyntaxCheck${randomInt}.py`;\n            const writeFilePromise = (0, util_1.promisify)(fs_1.writeFile);\n            return writeFilePromise(filePath, code).then(()=>{\n                return this.checkSyntaxFile(filePath);\n            });\n        });\n    }\n    static getPythonPath() {\n        return this.defaultOptions.pythonPath ? this.defaultOptions.pythonPath : this.defaultPythonPath;\n    }\n    /**\r\n     * checks syntax without executing code\r\n     * @returns {Promise} rejects w/ stderr if syntax failure\r\n     */ static checkSyntaxFile(filePath) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const pythonPath = this.getPythonPath();\n            let compileCommand = `${pythonPath} -m py_compile ${filePath}`;\n            return execPromise(compileCommand);\n        });\n    }\n    /**\r\n     * Runs a Python script and returns collected messages as a promise.\r\n     * If the promise is rejected, the err will probably be of type PythonShellErrorWithLogs\r\n     * @param scriptPath   The path to the script to execute\r\n     * @param options  The execution options\r\n     */ static run(scriptPath, options) {\n        return new Promise((resolve, reject)=>{\n            let pyshell = new PythonShell(scriptPath, options);\n            let output = [];\n            pyshell.on(\"message\", function(message) {\n                output.push(message);\n            }).end(function(err) {\n                if (err) {\n                    err.logs = output;\n                    reject(err);\n                } else resolve(output);\n            });\n        });\n    }\n    /**\r\n     * Runs the inputted string of python code and returns collected messages as a promise. DO NOT ALLOW UNTRUSTED USER INPUT HERE!\r\n     * @param code   The python code to execute\r\n     * @param options  The execution options\r\n     * @return a promise with the output from the python script\r\n     */ static runString(code, options) {\n        // put code in temp file\n        const randomInt = getRandomInt();\n        const filePath = os_1.tmpdir + path_1.sep + `pythonShellFile${randomInt}.py`;\n        (0, fs_1.writeFileSync)(filePath, code);\n        return PythonShell.run(filePath, options);\n    }\n    static getVersion(pythonPath) {\n        if (!pythonPath) pythonPath = this.getPythonPath();\n        return execPromise(pythonPath + \" --version\");\n    }\n    static getVersionSync(pythonPath) {\n        if (!pythonPath) pythonPath = this.getPythonPath();\n        return (0, child_process_1.execSync)(pythonPath + \" --version\").toString();\n    }\n    /**\r\n     * Parses an error thrown from the Python process through stderr\r\n     * @param  {string|Buffer} data The stderr contents to parse\r\n     * @return {Error} The parsed error with extended stack trace when traceback is available\r\n     */ parseError(data) {\n        let text = \"\" + data;\n        let error;\n        if (/^Traceback/.test(text)) {\n            // traceback data is available\n            let lines = text.trim().split(os_1.EOL);\n            let exception = lines.pop();\n            error = new PythonShellError(exception);\n            error.traceback = data;\n            // extend stack trace\n            error.stack += os_1.EOL + \"    ----- Python Traceback -----\" + os_1.EOL + \"  \";\n            error.stack += lines.slice(1).join(os_1.EOL + \"  \");\n        } else {\n            // otherwise, create a simpler error with stderr contents\n            error = new PythonShellError(text);\n        }\n        return error;\n    }\n    /**\r\n     * Sends a message to the Python shell through stdin\r\n     * Override this method to format data to be sent to the Python process\r\n     * @returns {PythonShell} The same instance for chaining calls\r\n     */ send(message) {\n        if (!this.stdin) throw new Error(\"stdin not open for writing\");\n        let data = this.formatter ? this.formatter(message) : message;\n        if (this.mode !== \"binary\") data += os_1.EOL;\n        this.stdin.write(data);\n        return this;\n    }\n    /**\r\n     * Closes the stdin stream. Unless python is listening for stdin in a loop\r\n     * this should cause the process to finish its work and close.\r\n     * @returns {PythonShell} The same instance for chaining calls\r\n     */ end(callback) {\n        if (this.childProcess.stdin) {\n            this.childProcess.stdin.end();\n        }\n        this._endCallback = callback;\n        return this;\n    }\n    /**\r\n     * Sends a kill signal to the process\r\n     * @returns {PythonShell} The same instance for chaining calls\r\n     */ kill(signal) {\n        this.terminated = this.childProcess.kill(signal);\n        return this;\n    }\n    /**\r\n     * Alias for kill.\r\n     * @deprecated\r\n     */ terminate(signal) {\n        // todo: remove this next breaking release\n        return this.kill(signal);\n    }\n}\nexports.PythonShell = PythonShell;\n// starting 2020 python2 is deprecated so we choose 3 as default\nPythonShell.defaultPythonPath = process.platform != \"win32\" ? \"python3\" : \"python\";\nPythonShell.defaultOptions = {}; //allow global overrides for options\n// built-in formatters\nPythonShell.format = {\n    text: function toText(data) {\n        if (!data) return \"\";\n        else if (typeof data !== \"string\") return data.toString();\n        return data;\n    },\n    json: function toJson(data) {\n        return JSON.stringify(data);\n    }\n};\n//built-in parsers\nPythonShell.parse = {\n    text: function asText(data) {\n        return data;\n    },\n    json: function asJson(data) {\n        return JSON.parse(data);\n    }\n};\n; //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcHl0aG9uLXNoZWxsL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsSUFBSUEsWUFBWSxDQUFDLE1BQUcsS0FBSyxPQUFHLEVBQUVBLFNBQVMsSUFBSyxTQUFVQyxPQUFPLEVBQUVDLFVBQVUsRUFBRUMsQ0FBQyxFQUFFQyxTQUFTO0lBQ25GLFNBQVNDLE1BQU1DLEtBQUs7UUFBSSxPQUFPQSxpQkFBaUJILElBQUlHLFFBQVEsSUFBSUgsRUFBRSxTQUFVSSxPQUFPO1lBQUlBLFFBQVFEO1FBQVE7SUFBSTtJQUMzRyxPQUFPLElBQUtILENBQUFBLEtBQU1BLENBQUFBLElBQUlLLE9BQU0sQ0FBQyxFQUFHLFNBQVVELE9BQU8sRUFBRUUsTUFBTTtRQUNyRCxTQUFTQyxVQUFVSixLQUFLO1lBQUksSUFBSTtnQkFBRUssS0FBS1AsVUFBVVEsSUFBSSxDQUFDTjtZQUFTLEVBQUUsT0FBT08sR0FBRztnQkFBRUosT0FBT0k7WUFBSTtRQUFFO1FBQzFGLFNBQVNDLFNBQVNSLEtBQUs7WUFBSSxJQUFJO2dCQUFFSyxLQUFLUCxTQUFTLENBQUMsUUFBUSxDQUFDRTtZQUFTLEVBQUUsT0FBT08sR0FBRztnQkFBRUosT0FBT0k7WUFBSTtRQUFFO1FBQzdGLFNBQVNGLEtBQUtJLE1BQU07WUFBSUEsT0FBT0MsSUFBSSxHQUFHVCxRQUFRUSxPQUFPVCxLQUFLLElBQUlELE1BQU1VLE9BQU9ULEtBQUssRUFBRVcsSUFBSSxDQUFDUCxXQUFXSTtRQUFXO1FBQzdHSCxLQUFLLENBQUNQLFlBQVlBLFVBQVVjLEtBQUssQ0FBQ2pCLFNBQVNDLGNBQWMsRUFBRSxHQUFHVSxJQUFJO0lBQ3RFO0FBQ0o7QUFDQU8sOENBQTZDO0lBQUViLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RlLG1CQUFtQixHQUFHQSwwQkFBMEIsR0FBR0EsZ0NBQWdDLEdBQUdBLHdCQUF3QixHQUFHLEtBQUs7QUFDdEgsTUFBTUssV0FBV0MsbUJBQU9BLENBQUMsc0JB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bGVzL3B5dGhvbi1zaGVsbC9pbmRleC5qcz85MmNjIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xyXG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcclxuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxyXG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XHJcbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xyXG4gICAgfSk7XHJcbn07XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuZXhwb3J0cy5QeXRob25TaGVsbCA9IGV4cG9ydHMuTmV3bGluZVRyYW5zZm9ybWVyID0gZXhwb3J0cy5QeXRob25TaGVsbEVycm9yV2l0aExvZ3MgPSBleHBvcnRzLlB5dGhvblNoZWxsRXJyb3IgPSB2b2lkIDA7XHJcbmNvbnN0IGV2ZW50c18xID0gcmVxdWlyZShcImV2ZW50c1wiKTtcclxuY29uc3QgY2hpbGRfcHJvY2Vzc18xID0gcmVxdWlyZShcImNoaWxkX3Byb2Nlc3NcIik7XHJcbmNvbnN0IG9zXzEgPSByZXF1aXJlKFwib3NcIik7XHJcbmNvbnN0IHBhdGhfMSA9IHJlcXVpcmUoXCJwYXRoXCIpO1xyXG5jb25zdCBzdHJlYW1fMSA9IHJlcXVpcmUoXCJzdHJlYW1cIik7XHJcbmNvbnN0IGZzXzEgPSByZXF1aXJlKFwiZnNcIik7XHJcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCJ1dGlsXCIpO1xyXG5mdW5jdGlvbiB0b0FycmF5KHNvdXJjZSkge1xyXG4gICAgaWYgKHR5cGVvZiBzb3VyY2UgPT09ICd1bmRlZmluZWQnIHx8IHNvdXJjZSA9PT0gbnVsbCkge1xyXG4gICAgICAgIHJldHVybiBbXTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKCFBcnJheS5pc0FycmF5KHNvdXJjZSkpIHtcclxuICAgICAgICByZXR1cm4gW3NvdXJjZV07XHJcbiAgICB9XHJcbiAgICByZXR1cm4gc291cmNlO1xyXG59XHJcbi8qKlxyXG4gKiBhZGRzIGFyZ3VtZW50cyBhcyBwcm9wZXJ0aWVzIHRvIG9ialxyXG4gKi9cclxuZnVuY3Rpb24gZXh0ZW5kKG9iaiwgLi4uYXJncykge1xyXG4gICAgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKS5mb3JFYWNoKGZ1bmN0aW9uIChzb3VyY2UpIHtcclxuICAgICAgICBpZiAoc291cmNlKSB7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGtleSBpbiBzb3VyY2UpIHtcclxuICAgICAgICAgICAgICAgIG9ialtrZXldID0gc291cmNlW2tleV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuICAgIHJldHVybiBvYmo7XHJcbn1cclxuLyoqXHJcbiAqIGdldHMgYSByYW5kb20gaW50IGZyb20gMC0xMDAwMDAwMDAwMFxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0UmFuZG9tSW50KCkge1xyXG4gICAgcmV0dXJuIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDEwMDAwMDAwMDAwKTtcclxufVxyXG5jb25zdCBleGVjUHJvbWlzZSA9ICgwLCB1dGlsXzEucHJvbWlzaWZ5KShjaGlsZF9wcm9jZXNzXzEuZXhlYyk7XHJcbmNsYXNzIFB5dGhvblNoZWxsRXJyb3IgZXh0ZW5kcyBFcnJvciB7XHJcbn1cclxuZXhwb3J0cy5QeXRob25TaGVsbEVycm9yID0gUHl0aG9uU2hlbGxFcnJvcjtcclxuY2xhc3MgUHl0aG9uU2hlbGxFcnJvcldpdGhMb2dzIGV4dGVuZHMgUHl0aG9uU2hlbGxFcnJvciB7XHJcbn1cclxuZXhwb3J0cy5QeXRob25TaGVsbEVycm9yV2l0aExvZ3MgPSBQeXRob25TaGVsbEVycm9yV2l0aExvZ3M7XHJcbi8qKlxyXG4gKiBUYWtlcyBpbiBhIHN0cmluZyBzdHJlYW0gYW5kIGVtaXRzIGJhdGNoZXMgc2VwZXJhdGVkIGJ5IG5ld2xpbmVzXHJcbiAqL1xyXG5jbGFzcyBOZXdsaW5lVHJhbnNmb3JtZXIgZXh0ZW5kcyBzdHJlYW1fMS5UcmFuc2Zvcm0ge1xyXG4gICAgX3RyYW5zZm9ybShjaHVuaywgZW5jb2RpbmcsIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgbGV0IGRhdGEgPSBjaHVuay50b1N0cmluZygpO1xyXG4gICAgICAgIGlmICh0aGlzLl9sYXN0TGluZURhdGEpXHJcbiAgICAgICAgICAgIGRhdGEgPSB0aGlzLl9sYXN0TGluZURhdGEgKyBkYXRhO1xyXG4gICAgICAgIGNvbnN0IGxpbmVzID0gZGF0YS5zcGxpdChvc18xLkVPTCk7XHJcbiAgICAgICAgdGhpcy5fbGFzdExpbmVEYXRhID0gbGluZXMucG9wKCk7XHJcbiAgICAgICAgLy9AdHMtaWdub3JlIHRoaXMgd29ya3MsIG5vZGUgaWdub3JlcyB0aGUgZW5jb2RpbmcgaWYgaXQncyBhIG51bWJlclxyXG4gICAgICAgIGxpbmVzLmZvckVhY2godGhpcy5wdXNoLmJpbmQodGhpcykpO1xyXG4gICAgICAgIGNhbGxiYWNrKCk7XHJcbiAgICB9XHJcbiAgICBfZmx1c2goZG9uZSkge1xyXG4gICAgICAgIGlmICh0aGlzLl9sYXN0TGluZURhdGEpXHJcbiAgICAgICAgICAgIHRoaXMucHVzaCh0aGlzLl9sYXN0TGluZURhdGEpO1xyXG4gICAgICAgIHRoaXMuX2xhc3RMaW5lRGF0YSA9IG51bGw7XHJcbiAgICAgICAgZG9uZSgpO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuTmV3bGluZVRyYW5zZm9ybWVyID0gTmV3bGluZVRyYW5zZm9ybWVyO1xyXG4vKipcclxuICogQW4gaW50ZXJhY3RpdmUgUHl0aG9uIHNoZWxsIGV4Y2hhbmdpbmcgZGF0YSB0aHJvdWdoIHN0ZGlvXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBzY3JpcHQgICAgVGhlIHB5dGhvbiBzY3JpcHQgdG8gZXhlY3V0ZVxyXG4gKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdIFRoZSBsYXVuY2ggb3B0aW9ucyAoYWxzbyBwYXNzZWQgdG8gY2hpbGRfcHJvY2Vzcy5zcGF3bilcclxuICogQHBhcmFtIFtzdGRvdXRTcGxpdHRlcl0gT3B0aW9uYWwuIFNwbGl0cyBzdGRvdXQgaW50byBjaHVua3MsIGRlZmF1bHRpbmcgdG8gc3BsaXR0aW5nIGludG8gbmV3bGluZS1zZXBlcmF0ZWQgbGluZXNcclxuICogQHBhcmFtIFtzdGRlcnJTcGxpdHRlcl0gT3B0aW9uYWwuIHNwbGl0cyBzdGRlcnIgaW50byBjaHVua3MsIGRlZmF1bHRpbmcgdG8gc3BsaXR0aW5nIGludG8gbmV3bGluZS1zZXBlcmF0ZWQgbGluZXNcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqL1xyXG5jbGFzcyBQeXRob25TaGVsbCBleHRlbmRzIGV2ZW50c18xLkV2ZW50RW1pdHRlciB7XHJcbiAgICAvKipcclxuICAgICAqIHNwYXducyBhIHB5dGhvbiBwcm9jZXNzXHJcbiAgICAgKiBAcGFyYW0gc2NyaXB0UGF0aCBwYXRoIHRvIHNjcmlwdC4gUmVsYXRpdmUgdG8gY3VycmVudCBkaXJlY3Rvcnkgb3Igb3B0aW9ucy5zY3JpcHRGb2xkZXIgaWYgc3BlY2lmaWVkXHJcbiAgICAgKiBAcGFyYW0gb3B0aW9uc1xyXG4gICAgICogQHBhcmFtIHN0ZG91dFNwbGl0dGVyIE9wdGlvbmFsLiBTcGxpdHMgc3Rkb3V0IGludG8gY2h1bmtzLCBkZWZhdWx0aW5nIHRvIHNwbGl0dGluZyBpbnRvIG5ld2xpbmUtc2VwZXJhdGVkIGxpbmVzXHJcbiAgICAgKiBAcGFyYW0gc3RkZXJyU3BsaXR0ZXIgT3B0aW9uYWwuIHNwbGl0cyBzdGRlcnIgaW50byBjaHVua3MsIGRlZmF1bHRpbmcgdG8gc3BsaXR0aW5nIGludG8gbmV3bGluZS1zZXBlcmF0ZWQgbGluZXNcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3Ioc2NyaXB0UGF0aCwgb3B0aW9ucywgc3Rkb3V0U3BsaXR0ZXIgPSBudWxsLCBzdGRlcnJTcGxpdHRlciA9IG51bGwpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIHJldHVybnMgZWl0aGVyIHB5dGhvbnNoZWxsIGZ1bmMgKGlmIHZhbCBzdHJpbmcpIG9yIGN1c3RvbSBmdW5jIChpZiB2YWwgRnVuY3Rpb24pXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gcmVzb2x2ZSh0eXBlLCB2YWwpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgICAgICAvLyB1c2UgYSBidWlsdC1pbiBmdW5jdGlvbiB1c2luZyBpdHMgbmFtZVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFB5dGhvblNoZWxsW3R5cGVdW3ZhbF07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICAgICAgLy8gdXNlIGEgY3VzdG9tIGZ1bmN0aW9uXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChzY3JpcHRQYXRoLnRyaW0oKS5sZW5ndGggPT0gMClcclxuICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJzY3JpcHRQYXRoIGNhbm5vdCBiZSBlbXB0eSEgWW91IG11c3QgZ2l2ZSBhIHNjcmlwdCBmb3IgcHl0aG9uIHRvIHJ1blwiKTtcclxuICAgICAgICBsZXQgc2VsZiA9IHRoaXM7XHJcbiAgICAgICAgbGV0IGVycm9yRGF0YSA9ICcnO1xyXG4gICAgICAgIGV2ZW50c18xLkV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xyXG4gICAgICAgIG9wdGlvbnMgPSBleHRlbmQoe30sIFB5dGhvblNoZWxsLmRlZmF1bHRPcHRpb25zLCBvcHRpb25zKTtcclxuICAgICAgICBsZXQgcHl0aG9uUGF0aDtcclxuICAgICAgICBpZiAoIW9wdGlvbnMucHl0aG9uUGF0aCkge1xyXG4gICAgICAgICAgICBweXRob25QYXRoID0gUHl0aG9uU2hlbGwuZGVmYXVsdFB5dGhvblBhdGg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICAgICAgcHl0aG9uUGF0aCA9IG9wdGlvbnMucHl0aG9uUGF0aDtcclxuICAgICAgICBsZXQgcHl0aG9uT3B0aW9ucyA9IHRvQXJyYXkob3B0aW9ucy5weXRob25PcHRpb25zKTtcclxuICAgICAgICBsZXQgc2NyaXB0QXJncyA9IHRvQXJyYXkob3B0aW9ucy5hcmdzKTtcclxuICAgICAgICB0aGlzLnNjcmlwdFBhdGggPSAoMCwgcGF0aF8xLmpvaW4pKG9wdGlvbnMuc2NyaXB0UGF0aCB8fCAnJywgc2NyaXB0UGF0aCk7XHJcbiAgICAgICAgdGhpcy5jb21tYW5kID0gcHl0aG9uT3B0aW9ucy5jb25jYXQodGhpcy5zY3JpcHRQYXRoLCBzY3JpcHRBcmdzKTtcclxuICAgICAgICB0aGlzLm1vZGUgPSBvcHRpb25zLm1vZGUgfHwgJ3RleHQnO1xyXG4gICAgICAgIHRoaXMuZm9ybWF0dGVyID0gcmVzb2x2ZSgnZm9ybWF0Jywgb3B0aW9ucy5mb3JtYXR0ZXIgfHwgdGhpcy5tb2RlKTtcclxuICAgICAgICB0aGlzLnBhcnNlciA9IHJlc29sdmUoJ3BhcnNlJywgb3B0aW9ucy5wYXJzZXIgfHwgdGhpcy5tb2RlKTtcclxuICAgICAgICAvLyBXZSBkb24ndCBleHBlY3QgdXNlcnMgdG8gZXZlciBmb3JtYXQgc3RkZXJyIGFzIEpTT04gc28gd2UgZGVmYXVsdCB0byB0ZXh0IG1vZGVcclxuICAgICAgICB0aGlzLnN0ZGVyclBhcnNlciA9IHJlc29sdmUoJ3BhcnNlJywgb3B0aW9ucy5zdGRlcnJQYXJzZXIgfHwgJ3RleHQnKTtcclxuICAgICAgICB0aGlzLnRlcm1pbmF0ZWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmNoaWxkUHJvY2VzcyA9ICgwLCBjaGlsZF9wcm9jZXNzXzEuc3Bhd24pKHB5dGhvblBhdGgsIHRoaXMuY29tbWFuZCwgb3B0aW9ucyk7XHJcbiAgICAgICAgWydzdGRvdXQnLCAnc3RkaW4nLCAnc3RkZXJyJ10uZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xyXG4gICAgICAgICAgICBzZWxmW25hbWVdID0gc2VsZi5jaGlsZFByb2Nlc3NbbmFtZV07XHJcbiAgICAgICAgICAgIHNlbGYucGFyc2VyICYmIHNlbGZbbmFtZV0gJiYgc2VsZltuYW1lXS5zZXRFbmNvZGluZyhvcHRpb25zLmVuY29kaW5nIHx8ICd1dGY4Jyk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgLy8gTm9kZSBidWZmZXJzIHN0ZG91dCZzdGRlcnIgaW4gYmF0Y2hlcyByZWdhcmRsZXNzIG9mIG5ld2xpbmUgcGxhY2VtZW50XHJcbiAgICAgICAgLy8gVGhpcyBpcyB0cm91Ymxlc29tZSBpZiB5b3Ugd2FudCB0byByZWNpZXZlIGRpc3RpbmN0IGluZGl2aWR1YWwgbWVzc2FnZXNcclxuICAgICAgICAvLyBmb3IgZXhhbXBsZSBKU09OIHBhcnNpbmcgYnJlYWtzIGlmIGl0IHJlY2lldmVzIHBhcnRpYWwgSlNPTlxyXG4gICAgICAgIC8vIHNvIHdlIHVzZSBuZXdsaW5lVHJhbnNmb3JtZXIgdG8gZW1pdCBlYWNoIGJhdGNoIHNlcGVyYXRlZCBieSBuZXdsaW5lXHJcbiAgICAgICAgaWYgKHRoaXMucGFyc2VyICYmIHRoaXMuc3Rkb3V0KSB7XHJcbiAgICAgICAgICAgIGlmICghc3Rkb3V0U3BsaXR0ZXIpXHJcbiAgICAgICAgICAgICAgICBzdGRvdXRTcGxpdHRlciA9IG5ldyBOZXdsaW5lVHJhbnNmb3JtZXIoKTtcclxuICAgICAgICAgICAgLy8gbm90ZSB0aGF0IHNldHRpbmcgdGhlIGVuY29kaW5nIHR1cm5zIHRoZSBjaHVuayBpbnRvIGEgc3RyaW5nXHJcbiAgICAgICAgICAgIHN0ZG91dFNwbGl0dGVyLnNldEVuY29kaW5nKG9wdGlvbnMuZW5jb2RpbmcgfHwgJ3V0ZjgnKTtcclxuICAgICAgICAgICAgdGhpcy5zdGRvdXQucGlwZShzdGRvdXRTcGxpdHRlcikub24oJ2RhdGEnLCAoY2h1bmspID0+IHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnbWVzc2FnZScsIHNlbGYucGFyc2VyKGNodW5rKSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBsaXN0ZW4gdG8gc3RkZXJyIGFuZCBlbWl0IGVycm9ycyBmb3IgaW5jb21pbmcgZGF0YVxyXG4gICAgICAgIGlmICh0aGlzLnN0ZGVyclBhcnNlciAmJiB0aGlzLnN0ZGVycikge1xyXG4gICAgICAgICAgICBpZiAoIXN0ZGVyclNwbGl0dGVyKVxyXG4gICAgICAgICAgICAgICAgc3RkZXJyU3BsaXR0ZXIgPSBuZXcgTmV3bGluZVRyYW5zZm9ybWVyKCk7XHJcbiAgICAgICAgICAgIC8vIG5vdGUgdGhhdCBzZXR0aW5nIHRoZSBlbmNvZGluZyB0dXJucyB0aGUgY2h1bmsgaW50byBhIHN0cmluZ1xyXG4gICAgICAgICAgICBzdGRlcnJTcGxpdHRlci5zZXRFbmNvZGluZyhvcHRpb25zLmVuY29kaW5nIHx8ICd1dGY4Jyk7XHJcbiAgICAgICAgICAgIHRoaXMuc3RkZXJyLnBpcGUoc3RkZXJyU3BsaXR0ZXIpLm9uKCdkYXRhJywgKGNodW5rKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ3N0ZGVycicsIHNlbGYuc3RkZXJyUGFyc2VyKGNodW5rKSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5zdGRlcnIpIHtcclxuICAgICAgICAgICAgdGhpcy5zdGRlcnIub24oJ2RhdGEnLCBmdW5jdGlvbiAoZGF0YSkge1xyXG4gICAgICAgICAgICAgICAgZXJyb3JEYXRhICs9ICcnICsgZGF0YTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHRoaXMuc3RkZXJyLm9uKCdlbmQnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBzZWxmLnN0ZGVyckhhc0VuZGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHRlcm1pbmF0ZUlmTmVlZGVkKCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgc2VsZi5zdGRlcnJIYXNFbmRlZCA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLnN0ZG91dCkge1xyXG4gICAgICAgICAgICB0aGlzLnN0ZG91dC5vbignZW5kJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgc2VsZi5zdGRvdXRIYXNFbmRlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB0ZXJtaW5hdGVJZk5lZWRlZCgpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHNlbGYuc3Rkb3V0SGFzRW5kZWQgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmNoaWxkUHJvY2Vzcy5vbignZXJyb3InLCBmdW5jdGlvbiAoZXJyKSB7XHJcbiAgICAgICAgICAgIHNlbGYuZW1pdCgnZXJyb3InLCBlcnIpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuY2hpbGRQcm9jZXNzLm9uKCdleGl0JywgZnVuY3Rpb24gKGNvZGUsIHNpZ25hbCkge1xyXG4gICAgICAgICAgICBzZWxmLmV4aXRDb2RlID0gY29kZTtcclxuICAgICAgICAgICAgc2VsZi5leGl0U2lnbmFsID0gc2lnbmFsO1xyXG4gICAgICAgICAgICB0ZXJtaW5hdGVJZk5lZWRlZCgpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGZ1bmN0aW9uIHRlcm1pbmF0ZUlmTmVlZGVkKCkge1xyXG4gICAgICAgICAgICBpZiAoIXNlbGYuc3RkZXJySGFzRW5kZWQgfHwgIXNlbGYuc3Rkb3V0SGFzRW5kZWQgfHwgKHNlbGYuZXhpdENvZGUgPT0gbnVsbCAmJiBzZWxmLmV4aXRTaWduYWwgPT0gbnVsbCkpXHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIGxldCBlcnI7XHJcbiAgICAgICAgICAgIGlmIChzZWxmLmV4aXRDb2RlICYmIHNlbGYuZXhpdENvZGUgIT09IDApIHtcclxuICAgICAgICAgICAgICAgIGlmIChlcnJvckRhdGEpIHtcclxuICAgICAgICAgICAgICAgICAgICBlcnIgPSBzZWxmLnBhcnNlRXJyb3IoZXJyb3JEYXRhKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGVyciA9IG5ldyBQeXRob25TaGVsbEVycm9yKCdwcm9jZXNzIGV4aXRlZCB3aXRoIGNvZGUgJyArIHNlbGYuZXhpdENvZGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZXJyID0gZXh0ZW5kKGVyciwge1xyXG4gICAgICAgICAgICAgICAgICAgIGV4ZWN1dGFibGU6IHB5dGhvblBhdGgsXHJcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9uczogcHl0aG9uT3B0aW9ucy5sZW5ndGggPyBweXRob25PcHRpb25zIDogbnVsbCxcclxuICAgICAgICAgICAgICAgICAgICBzY3JpcHQ6IHNlbGYuc2NyaXB0UGF0aCxcclxuICAgICAgICAgICAgICAgICAgICBhcmdzOiBzY3JpcHRBcmdzLmxlbmd0aCA/IHNjcmlwdEFyZ3MgOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgICAgIGV4aXRDb2RlOiBzZWxmLmV4aXRDb2RlXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIC8vIGRvIG5vdCBlbWl0IGVycm9yIGlmIG9ubHkgYSBjYWxsYmFjayBpcyB1c2VkXHJcbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5saXN0ZW5lcnMoJ3B5dGhvbkVycm9yJykubGVuZ3RoIHx8ICFzZWxmLl9lbmRDYWxsYmFjaykge1xyXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuZW1pdCgncHl0aG9uRXJyb3InLCBlcnIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHNlbGYudGVybWluYXRlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIHNlbGYuZW1pdCgnY2xvc2UnKTtcclxuICAgICAgICAgICAgc2VsZi5fZW5kQ2FsbGJhY2sgJiYgc2VsZi5fZW5kQ2FsbGJhY2soZXJyLCBzZWxmLmV4aXRDb2RlLCBzZWxmLmV4aXRTaWduYWwpO1xyXG4gICAgICAgIH1cclxuICAgICAgICA7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIGNoZWNrcyBzeW50YXggd2l0aG91dCBleGVjdXRpbmcgY29kZVxyXG4gICAgICogQHJldHVybnMgcmVqZWN0cyBwcm9taXNlIHcvIHN0cmluZyBlcnJvciBvdXRwdXQgaWYgc3ludGF4IGZhaWx1cmVcclxuICAgICAqL1xyXG4gICAgc3RhdGljIGNoZWNrU3ludGF4KGNvZGUpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICBjb25zdCByYW5kb21JbnQgPSBnZXRSYW5kb21JbnQoKTtcclxuICAgICAgICAgICAgY29uc3QgZmlsZVBhdGggPSAoMCwgb3NfMS50bXBkaXIpKCkgKyBwYXRoXzEuc2VwICsgYHB5dGhvblNoZWxsU3ludGF4Q2hlY2ske3JhbmRvbUludH0ucHlgO1xyXG4gICAgICAgICAgICBjb25zdCB3cml0ZUZpbGVQcm9taXNlID0gKDAsIHV0aWxfMS5wcm9taXNpZnkpKGZzXzEud3JpdGVGaWxlKTtcclxuICAgICAgICAgICAgcmV0dXJuIHdyaXRlRmlsZVByb21pc2UoZmlsZVBhdGgsIGNvZGUpLnRoZW4oKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2hlY2tTeW50YXhGaWxlKGZpbGVQYXRoKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgZ2V0UHl0aG9uUGF0aCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5kZWZhdWx0T3B0aW9ucy5weXRob25QYXRoID8gdGhpcy5kZWZhdWx0T3B0aW9ucy5weXRob25QYXRoIDogdGhpcy5kZWZhdWx0UHl0aG9uUGF0aDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogY2hlY2tzIHN5bnRheCB3aXRob3V0IGV4ZWN1dGluZyBjb2RlXHJcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gcmVqZWN0cyB3LyBzdGRlcnIgaWYgc3ludGF4IGZhaWx1cmVcclxuICAgICAqL1xyXG4gICAgc3RhdGljIGNoZWNrU3ludGF4RmlsZShmaWxlUGF0aCkge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHB5dGhvblBhdGggPSB0aGlzLmdldFB5dGhvblBhdGgoKTtcclxuICAgICAgICAgICAgbGV0IGNvbXBpbGVDb21tYW5kID0gYCR7cHl0aG9uUGF0aH0gLW0gcHlfY29tcGlsZSAke2ZpbGVQYXRofWA7XHJcbiAgICAgICAgICAgIHJldHVybiBleGVjUHJvbWlzZShjb21waWxlQ29tbWFuZCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJ1bnMgYSBQeXRob24gc2NyaXB0IGFuZCByZXR1cm5zIGNvbGxlY3RlZCBtZXNzYWdlcyBhcyBhIHByb21pc2UuXHJcbiAgICAgKiBJZiB0aGUgcHJvbWlzZSBpcyByZWplY3RlZCwgdGhlIGVyciB3aWxsIHByb2JhYmx5IGJlIG9mIHR5cGUgUHl0aG9uU2hlbGxFcnJvcldpdGhMb2dzXHJcbiAgICAgKiBAcGFyYW0gc2NyaXB0UGF0aCAgIFRoZSBwYXRoIHRvIHRoZSBzY3JpcHQgdG8gZXhlY3V0ZVxyXG4gICAgICogQHBhcmFtIG9wdGlvbnMgIFRoZSBleGVjdXRpb24gb3B0aW9uc1xyXG4gICAgICovXHJcbiAgICBzdGF0aWMgcnVuKHNjcmlwdFBhdGgsIG9wdGlvbnMpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICAgICAgICBsZXQgcHlzaGVsbCA9IG5ldyBQeXRob25TaGVsbChzY3JpcHRQYXRoLCBvcHRpb25zKTtcclxuICAgICAgICAgICAgbGV0IG91dHB1dCA9IFtdO1xyXG4gICAgICAgICAgICBweXNoZWxsLm9uKCdtZXNzYWdlJywgZnVuY3Rpb24gKG1lc3NhZ2UpIHtcclxuICAgICAgICAgICAgICAgIG91dHB1dC5wdXNoKG1lc3NhZ2UpO1xyXG4gICAgICAgICAgICB9KS5lbmQoZnVuY3Rpb24gKGVycikge1xyXG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xyXG4gICAgICAgICAgICAgICAgICAgIGVyci5sb2dzID0gb3V0cHV0O1xyXG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUob3V0cHV0KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIFJ1bnMgdGhlIGlucHV0dGVkIHN0cmluZyBvZiBweXRob24gY29kZSBhbmQgcmV0dXJucyBjb2xsZWN0ZWQgbWVzc2FnZXMgYXMgYSBwcm9taXNlLiBETyBOT1QgQUxMT1cgVU5UUlVTVEVEIFVTRVIgSU5QVVQgSEVSRSFcclxuICAgICAqIEBwYXJhbSBjb2RlICAgVGhlIHB5dGhvbiBjb2RlIHRvIGV4ZWN1dGVcclxuICAgICAqIEBwYXJhbSBvcHRpb25zICBUaGUgZXhlY3V0aW9uIG9wdGlvbnNcclxuICAgICAqIEByZXR1cm4gYSBwcm9taXNlIHdpdGggdGhlIG91dHB1dCBmcm9tIHRoZSBweXRob24gc2NyaXB0XHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBydW5TdHJpbmcoY29kZSwgb3B0aW9ucykge1xyXG4gICAgICAgIC8vIHB1dCBjb2RlIGluIHRlbXAgZmlsZVxyXG4gICAgICAgIGNvbnN0IHJhbmRvbUludCA9IGdldFJhbmRvbUludCgpO1xyXG4gICAgICAgIGNvbnN0IGZpbGVQYXRoID0gb3NfMS50bXBkaXIgKyBwYXRoXzEuc2VwICsgYHB5dGhvblNoZWxsRmlsZSR7cmFuZG9tSW50fS5weWA7XHJcbiAgICAgICAgKDAsIGZzXzEud3JpdGVGaWxlU3luYykoZmlsZVBhdGgsIGNvZGUpO1xyXG4gICAgICAgIHJldHVybiBQeXRob25TaGVsbC5ydW4oZmlsZVBhdGgsIG9wdGlvbnMpO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgc3RhdGljIGdldFZlcnNpb24ocHl0aG9uUGF0aCkge1xyXG4gICAgICAgIGlmICghcHl0aG9uUGF0aClcclxuICAgICAgICAgICAgcHl0aG9uUGF0aCA9IHRoaXMuZ2V0UHl0aG9uUGF0aCgpO1xyXG4gICAgICAgIHJldHVybiBleGVjUHJvbWlzZShweXRob25QYXRoICsgXCIgLS12ZXJzaW9uXCIpO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGdldFZlcnNpb25TeW5jKHB5dGhvblBhdGgpIHtcclxuICAgICAgICBpZiAoIXB5dGhvblBhdGgpXHJcbiAgICAgICAgICAgIHB5dGhvblBhdGggPSB0aGlzLmdldFB5dGhvblBhdGgoKTtcclxuICAgICAgICByZXR1cm4gKDAsIGNoaWxkX3Byb2Nlc3NfMS5leGVjU3luYykocHl0aG9uUGF0aCArIFwiIC0tdmVyc2lvblwiKS50b1N0cmluZygpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBQYXJzZXMgYW4gZXJyb3IgdGhyb3duIGZyb20gdGhlIFB5dGhvbiBwcm9jZXNzIHRocm91Z2ggc3RkZXJyXHJcbiAgICAgKiBAcGFyYW0gIHtzdHJpbmd8QnVmZmVyfSBkYXRhIFRoZSBzdGRlcnIgY29udGVudHMgdG8gcGFyc2VcclxuICAgICAqIEByZXR1cm4ge0Vycm9yfSBUaGUgcGFyc2VkIGVycm9yIHdpdGggZXh0ZW5kZWQgc3RhY2sgdHJhY2Ugd2hlbiB0cmFjZWJhY2sgaXMgYXZhaWxhYmxlXHJcbiAgICAgKi9cclxuICAgIHBhcnNlRXJyb3IoZGF0YSkge1xyXG4gICAgICAgIGxldCB0ZXh0ID0gJycgKyBkYXRhO1xyXG4gICAgICAgIGxldCBlcnJvcjtcclxuICAgICAgICBpZiAoL15UcmFjZWJhY2svLnRlc3QodGV4dCkpIHtcclxuICAgICAgICAgICAgLy8gdHJhY2ViYWNrIGRhdGEgaXMgYXZhaWxhYmxlXHJcbiAgICAgICAgICAgIGxldCBsaW5lcyA9IHRleHQudHJpbSgpLnNwbGl0KG9zXzEuRU9MKTtcclxuICAgICAgICAgICAgbGV0IGV4Y2VwdGlvbiA9IGxpbmVzLnBvcCgpO1xyXG4gICAgICAgICAgICBlcnJvciA9IG5ldyBQeXRob25TaGVsbEVycm9yKGV4Y2VwdGlvbik7XHJcbiAgICAgICAgICAgIGVycm9yLnRyYWNlYmFjayA9IGRhdGE7XHJcbiAgICAgICAgICAgIC8vIGV4dGVuZCBzdGFjayB0cmFjZVxyXG4gICAgICAgICAgICBlcnJvci5zdGFjayArPSBvc18xLkVPTCArICcgICAgLS0tLS0gUHl0aG9uIFRyYWNlYmFjayAtLS0tLScgKyBvc18xLkVPTCArICcgICc7XHJcbiAgICAgICAgICAgIGVycm9yLnN0YWNrICs9IGxpbmVzLnNsaWNlKDEpLmpvaW4ob3NfMS5FT0wgKyAnICAnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIG90aGVyd2lzZSwgY3JlYXRlIGEgc2ltcGxlciBlcnJvciB3aXRoIHN0ZGVyciBjb250ZW50c1xyXG4gICAgICAgICAgICBlcnJvciA9IG5ldyBQeXRob25TaGVsbEVycm9yKHRleHQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZXJyb3I7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIFNlbmRzIGEgbWVzc2FnZSB0byB0aGUgUHl0aG9uIHNoZWxsIHRocm91Z2ggc3RkaW5cclxuICAgICAqIE92ZXJyaWRlIHRoaXMgbWV0aG9kIHRvIGZvcm1hdCBkYXRhIHRvIGJlIHNlbnQgdG8gdGhlIFB5dGhvbiBwcm9jZXNzXHJcbiAgICAgKiBAcmV0dXJucyB7UHl0aG9uU2hlbGx9IFRoZSBzYW1lIGluc3RhbmNlIGZvciBjaGFpbmluZyBjYWxsc1xyXG4gICAgICovXHJcbiAgICBzZW5kKG1lc3NhZ2UpIHtcclxuICAgICAgICBpZiAoIXRoaXMuc3RkaW4pXHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInN0ZGluIG5vdCBvcGVuIGZvciB3cml0aW5nXCIpO1xyXG4gICAgICAgIGxldCBkYXRhID0gdGhpcy5mb3JtYXR0ZXIgPyB0aGlzLmZvcm1hdHRlcihtZXNzYWdlKSA6IG1lc3NhZ2U7XHJcbiAgICAgICAgaWYgKHRoaXMubW9kZSAhPT0gJ2JpbmFyeScpXHJcbiAgICAgICAgICAgIGRhdGEgKz0gb3NfMS5FT0w7XHJcbiAgICAgICAgdGhpcy5zdGRpbi53cml0ZShkYXRhKTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogQ2xvc2VzIHRoZSBzdGRpbiBzdHJlYW0uIFVubGVzcyBweXRob24gaXMgbGlzdGVuaW5nIGZvciBzdGRpbiBpbiBhIGxvb3BcclxuICAgICAqIHRoaXMgc2hvdWxkIGNhdXNlIHRoZSBwcm9jZXNzIHRvIGZpbmlzaCBpdHMgd29yayBhbmQgY2xvc2UuXHJcbiAgICAgKiBAcmV0dXJucyB7UHl0aG9uU2hlbGx9IFRoZSBzYW1lIGluc3RhbmNlIGZvciBjaGFpbmluZyBjYWxsc1xyXG4gICAgICovXHJcbiAgICBlbmQoY2FsbGJhY2spIHtcclxuICAgICAgICBpZiAodGhpcy5jaGlsZFByb2Nlc3Muc3RkaW4pIHtcclxuICAgICAgICAgICAgdGhpcy5jaGlsZFByb2Nlc3Muc3RkaW4uZW5kKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX2VuZENhbGxiYWNrID0gY2FsbGJhY2s7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIFNlbmRzIGEga2lsbCBzaWduYWwgdG8gdGhlIHByb2Nlc3NcclxuICAgICAqIEByZXR1cm5zIHtQeXRob25TaGVsbH0gVGhlIHNhbWUgaW5zdGFuY2UgZm9yIGNoYWluaW5nIGNhbGxzXHJcbiAgICAgKi9cclxuICAgIGtpbGwoc2lnbmFsKSB7XHJcbiAgICAgICAgdGhpcy50ZXJtaW5hdGVkID0gdGhpcy5jaGlsZFByb2Nlc3Mua2lsbChzaWduYWwpO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBBbGlhcyBmb3Iga2lsbC5cclxuICAgICAqIEBkZXByZWNhdGVkXHJcbiAgICAgKi9cclxuICAgIHRlcm1pbmF0ZShzaWduYWwpIHtcclxuICAgICAgICAvLyB0b2RvOiByZW1vdmUgdGhpcyBuZXh0IGJyZWFraW5nIHJlbGVhc2VcclxuICAgICAgICByZXR1cm4gdGhpcy5raWxsKHNpZ25hbCk7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5QeXRob25TaGVsbCA9IFB5dGhvblNoZWxsO1xyXG4vLyBzdGFydGluZyAyMDIwIHB5dGhvbjIgaXMgZGVwcmVjYXRlZCBzbyB3ZSBjaG9vc2UgMyBhcyBkZWZhdWx0XHJcblB5dGhvblNoZWxsLmRlZmF1bHRQeXRob25QYXRoID0gcHJvY2Vzcy5wbGF0Zm9ybSAhPSBcIndpbjMyXCIgPyBcInB5dGhvbjNcIiA6IFwicHl0aG9uXCI7XHJcblB5dGhvblNoZWxsLmRlZmF1bHRPcHRpb25zID0ge307IC8vYWxsb3cgZ2xvYmFsIG92ZXJyaWRlcyBmb3Igb3B0aW9uc1xyXG4vLyBidWlsdC1pbiBmb3JtYXR0ZXJzXHJcblB5dGhvblNoZWxsLmZvcm1hdCA9IHtcclxuICAgIHRleHQ6IGZ1bmN0aW9uIHRvVGV4dChkYXRhKSB7XHJcbiAgICAgICAgaWYgKCFkYXRhKVxyXG4gICAgICAgICAgICByZXR1cm4gJyc7XHJcbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIGRhdGEgIT09ICdzdHJpbmcnKVxyXG4gICAgICAgICAgICByZXR1cm4gZGF0YS50b1N0cmluZygpO1xyXG4gICAgICAgIHJldHVybiBkYXRhO1xyXG4gICAgfSxcclxuICAgIGpzb246IGZ1bmN0aW9uIHRvSnNvbihkYXRhKSB7XHJcbiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGRhdGEpO1xyXG4gICAgfVxyXG59O1xyXG4vL2J1aWx0LWluIHBhcnNlcnNcclxuUHl0aG9uU2hlbGwucGFyc2UgPSB7XHJcbiAgICB0ZXh0OiBmdW5jdGlvbiBhc1RleHQoZGF0YSkge1xyXG4gICAgICAgIHJldHVybiBkYXRhO1xyXG4gICAgfSxcclxuICAgIGpzb246IGZ1bmN0aW9uIGFzSnNvbihkYXRhKSB7XHJcbiAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UoZGF0YSk7XHJcbiAgICB9XHJcbn07XHJcbjtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbIl9fYXdhaXRlciIsInRoaXNBcmciLCJfYXJndW1lbnRzIiwiUCIsImdlbmVyYXRvciIsImFkb3B0IiwidmFsdWUiLCJyZXNvbHZlIiwiUHJvbWlzZSIsInJlamVjdCIsImZ1bGZpbGxlZCIsInN0ZXAiLCJuZXh0IiwiZSIsInJlamVjdGVkIiwicmVzdWx0IiwiZG9uZSIsInRoZW4iLCJhcHBseSIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsIlB5dGhvblNoZWxsIiwiTmV3bGluZVRyYW5zZm9ybWVyIiwiUHl0aG9uU2hlbGxFcnJvcldpdGhMb2dzIiwiUHl0aG9uU2hlbGxFcnJvciIsImV2ZW50c18xIiwicmVxdWlyZSIsImNoaWxkX3Byb2Nlc3NfMSIsIm9zXzEiLCJwYXRoXzEiLCJzdHJlYW1fMSIsImZzXzEiLCJ1dGlsXzEiLCJ0b0FycmF5Iiwic291cmNlIiwiQXJyYXkiLCJpc0FycmF5IiwiZXh0ZW5kIiwib2JqIiwiYXJncyIsInByb3RvdHlwZSIsInNsaWNlIiwiY2FsbCIsImFyZ3VtZW50cyIsImZvckVhY2giLCJrZXkiLCJnZXRSYW5kb21JbnQiLCJNYXRoIiwiZmxvb3IiLCJyYW5kb20iLCJleGVjUHJvbWlzZSIsInByb21pc2lmeSIsImV4ZWMiLCJFcnJvciIsIlRyYW5zZm9ybSIsIl90cmFuc2Zvcm0iLCJjaHVuayIsImVuY29kaW5nIiwiY2FsbGJhY2siLCJkYXRhIiwidG9TdHJpbmciLCJfbGFzdExpbmVEYXRhIiwibGluZXMiLCJzcGxpdCIsIkVPTCIsInBvcCIsInB1c2giLCJiaW5kIiwiX2ZsdXNoIiwiRXZlbnRFbWl0dGVyIiwiY29uc3RydWN0b3IiLCJzY3JpcHRQYXRoIiwib3B0aW9ucyIsInN0ZG91dFNwbGl0dGVyIiwic3RkZXJyU3BsaXR0ZXIiLCJ0eXBlIiwidmFsIiwidHJpbSIsImxlbmd0aCIsInNlbGYiLCJlcnJvckRhdGEiLCJkZWZhdWx0T3B0aW9ucyIsInB5dGhvblBhdGgiLCJkZWZhdWx0UHl0aG9uUGF0aCIsInB5dGhvbk9wdGlvbnMiLCJzY3JpcHRBcmdzIiwiam9pbiIsImNvbW1hbmQiLCJjb25jYXQiLCJtb2RlIiwiZm9ybWF0dGVyIiwicGFyc2VyIiwic3RkZXJyUGFyc2VyIiwidGVybWluYXRlZCIsImNoaWxkUHJvY2VzcyIsInNwYXduIiwibmFtZSIsInNldEVuY29kaW5nIiwic3Rkb3V0IiwicGlwZSIsIm9uIiwiZW1pdCIsInN0ZGVyciIsInN0ZGVyckhhc0VuZGVkIiwidGVybWluYXRlSWZOZWVkZWQiLCJzdGRvdXRIYXNFbmRlZCIsImVyciIsImNvZGUiLCJzaWduYWwiLCJleGl0Q29kZSIsImV4aXRTaWduYWwiLCJwYXJzZUVycm9yIiwiZXhlY3V0YWJsZSIsInNjcmlwdCIsImxpc3RlbmVycyIsIl9lbmRDYWxsYmFjayIsImNoZWNrU3ludGF4IiwicmFuZG9tSW50IiwiZmlsZVBhdGgiLCJ0bXBkaXIiLCJzZXAiLCJ3cml0ZUZpbGVQcm9taXNlIiwid3JpdGVGaWxlIiwiY2hlY2tTeW50YXhGaWxlIiwiZ2V0UHl0aG9uUGF0aCIsImNvbXBpbGVDb21tYW5kIiwicnVuIiwicHlzaGVsbCIsIm91dHB1dCIsIm1lc3NhZ2UiLCJlbmQiLCJsb2dzIiwicnVuU3RyaW5nIiwid3JpdGVGaWxlU3luYyIsImdldFZlcnNpb24iLCJnZXRWZXJzaW9uU3luYyIsImV4ZWNTeW5jIiwidGV4dCIsImVycm9yIiwidGVzdCIsImV4Y2VwdGlvbiIsInRyYWNlYmFjayIsInN0YWNrIiwic2VuZCIsInN0ZGluIiwid3JpdGUiLCJraWxsIiwidGVybWluYXRlIiwicHJvY2VzcyIsInBsYXRmb3JtIiwiZm9ybWF0IiwidG9UZXh0IiwianNvbiIsInRvSnNvbiIsIkpTT04iLCJzdHJpbmdpZnkiLCJwYXJzZSIsImFzVGV4dCIsImFzSnNvbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/python-shell/index.js\n");

/***/ })

};
;